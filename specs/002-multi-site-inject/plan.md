# Implementation Plan: Multi-Site Button Injection Support

**Branch**: `002-multi-site-inject` | **Date**: 2025-11-29 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/002-multi-site-inject/spec.md`

## Summary

Add "优化指令" button injection support for manus.im and gemini.google.com, while reorganizing the content script codebase to separate site-specific injection logic into individual files per site. The core message passing and LLM integration remain unchanged. Confirm manifest.json includes host permissions for both new sites.

## Technical Context

**Language/Version**: TypeScript ES2020 (Chrome Extension MV3)
**Primary Dependencies**: esbuild (bundler only), Chrome Extension APIs
**Storage**: chrome.storage.local (API key), chrome.storage.sync (config)
**Testing**: Manual testing (UI/Chrome APIs) + optional Node.js built-in tests for pure functions (selectors, prompt utils) if extracted
**Target Platform**: Chrome browser (MV3 extension)
**Project Type**: Chrome Extension with multi-entry bundling
**Performance Goals**: Button appears within 2 seconds of page load on all sites
**Constraints**: <50ms selector detection, graceful degradation on DOM changes
**Scale/Scope**: 3 supported sites (ChatGPT, Manus, Gemini)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Client-Side Only | ✅ PASS | No backend changes required |
| II. Module Isolation | ✅ PASS | New files in `content/sites/` folder |
| III. API Key Security | ✅ PASS | No changes to API key handling |
| IV. Progressive Enhancement | ✅ PASS | Site-specific selectors + fallback strategies |
| V. User Feedback | ✅ PASS | Same button states across all sites |
| VI. Configuration Flexibility | ✅ PASS | No config changes needed |
| VII. Minimal Dependencies | ✅ PASS | No new dependencies |
| VIII. Lightweight Testing | ✅ PASS | Pure functions can be tested if extracted; UI/Chrome APIs remain manual |

## Project Structure

### Documentation (this feature)

```text
specs/002-multi-site-inject/
├── plan.md              # This file
├── research.md          # DOM analysis and selector strategies
├── tasks.md             # Task breakdown (generated by /speckit.tasks)
└── checklists/
    └── requirements.md  # Quality checklist
```

### Source Code Changes

```text
extension/src/content/
├── index.ts                    # Main entry (refactored to dispatch to site handlers)
├── button-styles.ts            # Shared button styling (unchanged)
├── content-script.css          # Shared CSS (extended for Manus/Gemini themes)
├── shared/                     # NEW: Shared utilities extracted from index.ts
│   ├── button-controller.ts    # Button creation, click handling, loading states
│   ├── prompt-utils.ts         # getPromptValue, setPromptValue
│   └── types.ts                # SiteHandler interface
└── sites/                      # NEW: Site-specific handlers
    ├── chatgpt.ts              # ChatGPT-specific selectors and insertion
    ├── manus.ts                # Manus-specific selectors and insertion
    └── gemini.ts               # Gemini-specific selectors and insertion
```

**Structure Decision**: Extend existing `extension/src/content/` with a `sites/` subfolder containing one file per supported site. This follows Constitution Principle II (Module Isolation) while maintaining the existing build configuration.

## Complexity Tracking

> No Constitution violations. All changes align with existing patterns.

| Aspect | Complexity | Justification |
|--------|------------|---------------|
| New folders | Low | Single `sites/` folder with 3 files |
| Interface extraction | Low | Simple `SiteHandler` interface |
| Build config | None | No changes to esbuild config needed |

---

## Phase 0: Research

### DOM Analysis

Based on user-provided HTML structures:

#### Manus.im DOM Structure

```html
<!-- Container with input and buttons -->
<div class="flex flex-col gap-3 rounded-[22px] ...">
  <!-- Input wrapper -->
  <div class="overflow-y-auto pl-4 pr-2">
    <textarea placeholder="Assign a task or ask anything" ...></textarea>
  </div>
  <!-- Button row -->
  <div class="px-3 flex gap-2 item-center">
    <!-- Left side: plus button, integrations -->
    <div class="flex gap-2 items-center flex-shrink-0">
      <button class="rounded-full border ..."><!-- Plus icon --></button>
      <!-- Integration icons -->
    </div>
    <!-- Right side: mic, send button -->
    <div class="min-w-0 flex gap-2 ml-auto ...">
      ...
    </div>
  </div>
</div>
```

**Input Selector**: `textarea[placeholder="Assign a task or ask anything"]` (fallback: `textarea`)
**Insertion Strategy**: Insert button after the plus button in `.flex.gap-2.items-center.flex-shrink-0` (primary anchor)

#### Gemini DOM Structure

```html
<div class="text-input-field ...">
  <!-- Text area wrapper -->
  <div class="text-input-field_textarea-wrapper">
    <rich-textarea ...>
      <div class="ql-editor textarea" contenteditable="true" role="textbox"
           aria-label="Enter a prompt here" data-placeholder="Ask Gemini">
        <p><br></p>
      </div>
    </rich-textarea>
  </div>
  <!-- Leading actions (upload, tools) -->
  <div class="leading-actions-wrapper ...">
    <uploader ...>
      <button mat-icon-button aria-label="Open upload file menu" ...></button>
    </uploader>
    <toolbox-drawer ...></toolbox-drawer>
  </div>
  <!-- Trailing actions (model picker, mic, send) -->
  <div class="trailing-actions-wrapper ...">
    ...
  </div>
</div>
```

**Input Selector**: `.ql-editor.textarea[contenteditable="true"][data-placeholder="Ask Gemini"]` (fallback: `div[role="textbox"][aria-label*="Enter a prompt here"]`, then generic `div.ql-editor[contenteditable="true"]`)
**Insertion Strategy**: Insert into `.leading-actions-wrapper` after the upload button (primary anchor)

### Selector Strategy per Site with Fallbacks

#### ChatGPT (Existing 4-level strategy)

**Input Selectors**: `div[role="textbox"]`, `#prompt-textarea`, `textarea[placeholder*="Message"]`

**Insertion Strategies** (in order):
1. Find `[data-testid="composer-plus-btn"]` and append to parent
2. Find `[class*="grid-area:leading"]` and append to `span.flex`
3. Insert before target's parent
4. Use `insertAdjacentElement('beforebegin')`

---

#### Manus (New 4-level strategy)

**Input Selectors**: `textarea[placeholder="Assign a task or ask anything"]`, `textarea[placeholder*="Assign"]`, `textarea[placeholder*="ask"]`, `textarea`

**Insertion Strategies** (in order):
1. Find `.flex.gap-2.items-center.flex-shrink-0`, locate first `button.rounded-full`, append after it
2. Find `.flex.gap-2.items-center.flex-shrink-0` and append as last child
3. Find `.px-3.flex.gap-2` (action bar) and append as last child
4. Insert before textarea parent element

**Fallback Rationale**: Progressively degrades from ideal placement (next to plus button) to generic positioning if DOM structure changes.

---

#### Gemini (New 5-level strategy)

**Input Selectors**: `.ql-editor.textarea[contenteditable="true"][data-placeholder="Ask Gemini"]`, `div[role="textbox"][aria-label*="Enter a prompt here"]`, `div.ql-editor[contenteditable="true"]`, `rich-textarea div[contenteditable="true"]`

**Insertion Strategies** (in order):
1. Find `.leading-actions-wrapper` and prepend (insertBefore first child)
2. Find `uploader.upload-button`, then find parent `.leading-actions-wrapper` and insert after uploader
3. Find `.leading-actions-wrapper` and append as last child
4. Find `.text-input-field_textarea-wrapper`, insert after `rich-textarea`
5. Insert before ql-editor parent element

**Fallback Rationale**: Handles various Angular Material restructuring patterns, with final fallback for any wrapper configuration.

### Theme Detection

| Site | Dark Mode Detection |
|------|---------------------|
| ChatGPT | `html.dark` class |
| Manus | CSS custom properties `--fill-input-chat`, `--border-main` (auto-handled by CSS vars) |
| Gemini | Material theming (Angular Material) - check for `.dark-theme` or similar |

---

## Phase 1: Design

### SiteHandler Interface

```typescript
// extension/src/content/shared/types.ts
export interface SiteHandler {
  /** Hostname patterns this handler supports */
  hostPatterns: string[];

  /** CSS selectors to find the prompt input, in priority order */
  inputSelectors: string[];

  /** Find the best DOM element to insert the button near */
  findInsertionPoint(input: HTMLElement): HTMLElement | null;

  /** Insert the button at the appropriate location */
  insertButton(button: HTMLButtonElement, insertionPoint: HTMLElement): void;

  /** Optional: Site-specific value reading (for rich text editors) */
  getPromptValue?(input: HTMLElement): string;

  /** Optional: Site-specific value setting (for rich text editors) */
  setPromptValue?(input: HTMLElement, value: string): void;
}
```

### CSS Updates

Extend `content-script.css` to handle Manus and Gemini styling contexts:

```css
/* Manus.im theme support - uses CSS custom properties */
:root .prompt-enhancer-btn {
  /* Inherit from Manus CSS vars if available */
  --btn-bg: var(--fill-input-chat, #000000);
  --btn-border: var(--border-main, transparent);
}

/* Gemini theme support - Material-like button */
rich-textarea ~ .prompt-enhancer-btn,
.leading-actions-wrapper .prompt-enhancer-btn {
  /* Match Gemini's button styling */
  height: 40px;
  border-radius: 20px;
}
```

### Refactoring Strategy

1. **Extract shared utilities** from current `index.ts`:
   - `getPromptValue()` → `shared/prompt-utils.ts`
   - `setPromptValue()` → `shared/prompt-utils.ts`
   - `handleOptimize()` → `shared/button-controller.ts`
   - `setLoading()` → `shared/button-controller.ts`

2. **Create site handlers**:
   - Move ChatGPT-specific logic to `sites/chatgpt.ts`
   - Create `sites/manus.ts` with Manus selectors and insertion
   - Create `sites/gemini.ts` with Gemini selectors and insertion
   - Use a shared button controller for consistent loading/error states and keyboard shortcut handling across all handlers

3. **Simplify `index.ts`**:
   - Import all site handlers
   - Match current host against handler patterns
   - Delegate to appropriate handler
   - Use a per-site MutationObserver strategy to re-inject after SPA navigation and prevent duplicate buttons

### SiteHandler Implementation Pattern

Each site handler will implement a `tryInsertStrategies()` method that attempts all fallback strategies:

```typescript
export class SiteHandler {
  private insertionStrategies: Array<() => boolean> = [];

  public insertButton(button: HTMLButtonElement, target: HTMLElement): void {
    // Populate strategies in order of preference
    this.insertionStrategies = [
      () => this.strategyPrimary(),
      () => this.strategySecondary(),
      () => this.strategyTertiary(),
      () => this.strategyFallback(),
    ];

    // Try each strategy until one succeeds
    for (const strategy of this.insertionStrategies) {
      if (strategy()) {
        return; // Successfully inserted
      }
    }

    console.error('All insertion strategies failed for', this.name);
  }

  // Site-specific implementations override these
  protected strategyPrimary(): boolean { return false; }
  protected strategySecondary(): boolean { return false; }
  protected strategyTertiary(): boolean { return false; }
  protected strategyFallback(): boolean { return false; }
}
```

**Benefits**:
- Clear progression through strategies
- Logs which strategy succeeded
- Easy to test each strategy independently
- Can be extended with new strategies if site DOM changes

### Build Considerations

The esbuild config bundles all content script files into a single `content-script.js`. No build changes needed - the new files will be bundled automatically as imports.

### Prompt Value Handling (Gemini)

- For Gemini’s Quill editor (`.ql-editor.textarea`), set optimized content by updating the editor’s inner HTML/text and dispatching `input` (and/or `change`) events so the app registers the change; read the current value via textContent/innerText to preserve formatting minimally.

---

## Open Questions (from user context)

The user provided detailed DOM structures which resolve most technical ambiguities. However, there are minor clarifications that can be addressed during implementation:

1. **Gemini setPromptValue**: The Quill editor (`ql-editor`) may need special handling for setting content. We'll use `innerHTML` or Quill's API if available.

2. **Manus theme**: Manus uses CSS custom properties. Our button will inherit these automatically if we use `var(--property)` in CSS.

---

## Next Steps

1. Run `/speckit.tasks` to generate the task breakdown
2. Implement tasks in order:
   - Refactor shared utilities
   - Create SiteHandler interface
   - Implement ChatGPT handler (refactor existing)
   - Implement Manus handler
   - Implement Gemini handler
   - Update CSS for multi-site support
   - Test on all three sites
